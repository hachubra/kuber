# Домашнее задание к занятию «Хранение в K8s. Часть 2»

### Цель задания

В тестовой среде Kubernetes нужно создать PV и продемострировать запись и хранение файлов.

------

### Чеклист готовности к домашнему заданию

1. Установленное K8s-решение (например, MicroK8S).
2. Установленный локальный kubectl.
3. Редактор YAML-файлов с подключенным GitHub-репозиторием.

------

### Дополнительные материалы для выполнения задания

1. [Инструкция по установке NFS в MicroK8S](https://microk8s.io/docs/nfs). 
2. [Описание Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/). 
3. [Описание динамического провижининга](https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/). 
4. [Описание Multitool](https://github.com/wbitt/Network-MultiTool).

------

### Задание 1

**Что нужно сделать**

Создать Deployment приложения, использующего локальный PV, созданный вручную.

1. Создать Deployment приложения, состоящего из контейнеров busybox и multitool.
2. Создать PV и PVC для подключения папки на локальной ноде, которая будет использована в поде.
3. Продемонстрировать, что multitool может читать файл, в который busybox пишет каждые пять секунд в общей директории. 
4. Удалить Deployment и PVC. Продемонстрировать, что после этого произошло с PV. Пояснить, почему.
5. Продемонстрировать, что файл сохранился на локальном диске ноды. Удалить PV.  Продемонстрировать что произошло с файлом после удаления PV. Пояснить, почему.
5. Предоставить манифесты, а также скриншоты или вывод необходимых команд.



#### Решение 1.

deploy:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: busy-multi
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: busy-multi
  template:
    metadata:
      labels:
        app: busy-multi
    spec:
      containers:
      - name: busybox
        image: busybox
        command: ["/bin/sh", "-c"]
        args: ["date >> /output/file.txt; sleep 5"] 
        volumeMounts:
        - name: vol1
          mountPath: /output
      - name: wbitt
        image: wbitt/network-multitool
        env:
        - name: HTTP_PORT
          value: "8080"
        - name: HTTPS_PORT 
          value: "8443"
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: vol1
          mountPath: /input
      volumes: 
      - name: vol1  
        persistentVolumeClaim:
          claimName: vol1-pvc

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: vol1-pvc
  namespace: default
spec:
  storageClassName: ""
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi


---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: vol1-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /var/data/pv1
```
Запуск и проверка:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl apply -f pv2.2.1.yaml 
persistentvolume/vol1-pv created
```
```bash
alex@ubu04:~/kuber2025/2.2$ kubectl get pv
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE
vol1-pv   1Gi        RWO            Retain           Available                          <unset>                          9s
```
```bash
alex@ubu04:~/kuber2025/2.2$ kubectl apply -f pvc2.2.1.yaml 
persistentvolumeclaim/vol1-pvc created
```
```bash
alex@ubu04:~/kuber2025/2.2$ kubectl get pvc
NAME       STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE
vol1-pvc   Bound    vol1-pv   1Gi        RWO                           <unset>                 4s
```
```bash
alex@ubu04:~/kuber2025/2.2$ kubectl apply -f deploy2.2.1.yaml 
deployment.apps/busy-multi created
```
```bash 
alex@ubu04:~/kuber2025/2.2$ kubectl get po
NAME                          READY   STATUS    RESTARTS   AGE
busy-multi-7d6b698b87-dgl7f   2/2     Running   0          6s
```

```bash
alex@ubu04:~/kuber2025/2.2$ ls  /var/data/pv1/
file.txt
```
```bash 
alex@ubu04:~/kuber2025/2.2$ cat  /var/data/pv1/file.txt 
Sat Aug 16 13:23:22 UTC 2025
Sat Aug 16 13:23:29 UTC 2025
Sat Aug 16 13:23:50 UTC 2025
Sat Aug 16 13:24:21 UTC 2025
Sat Aug 16 13:25:18 UTC 2025
Sat Aug 16 13:26:49 UTC 2025
```
Проверка чтения файла изнутри контейнера:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl exec -it deployments/busy-multi -c wbitt -- bash
busy-multi-7d6b698b87-dgl7f:/# cat /input/file.txt 
Sat Aug 16 13:23:22 UTC 2025
Sat Aug 16 13:23:29 UTC 2025
Sat Aug 16 13:23:50 UTC 2025
Sat Aug 16 13:24:21 UTC 2025
Sat Aug 16 13:25:18 UTC 2025
Sat Aug 16 13:26:49 UTC 2025
Sat Aug 16 13:29:42 UTC 2025
Sat Aug 16 13:34:50 UTC 2025
Sat Aug 16 13:41:04 UTC 2025
Sat Aug 16 13:41:11 UTC 2025
Sat Aug 16 13:41:29 UTC 2025
Sat Aug 16 13:42:02 UTC 2025
Sat Aug 16 13:42:58 UTC 2025
Sat Aug 16 13:44:38 UTC 2025
busy-multi-7d6b698b87-dgl7f:/# 
```

Удаление deployment и pvc:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl delete -f deploy2.2.1.yaml 
deployment.apps "busy-multi" deleted
alex@ubu04:~/kuber2025/2.2$ kubectl delete -f pvc2.2.1.yaml 
persistentvolumeclaim "vol1-pvc" deleted
alex@ubu04:~/kuber2025/2.2$ kubectl get po
No resources found in default namespace.
alex@ubu04:~/kuber2025/2.2$ kubectl get pvc
No resources found in default namespace.
alex@ubu04:~/kuber2025/2.2$ kubectl get pv
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM              STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE
vol1-pv   1Gi        RWO            Retain           Released   default/vol1-pvc                  <unset>                          6m30s
```
После удаления pv освободился и стал доступен для использования другим pvc, так как больше не используется удаленным pvc.

Файл по прежнему находится на своем месте:
```bash
alex@ubu04:~/kuber2025/2.2$ ll  /var/data/pv1/
total 12
drwxrwxrwx 2 root root 4096 авг 16 18:23 ./
drwxr-xr-x 3 root root 4096 авг 16 18:18 ../
-rw-r--r-- 1 root root  406 авг 16 18:44 file.txt
alex@ubu04:~/kuber2025/2.2$ 
```

Удаление pv:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl delete -f pv2.2.1.yaml
persistentvolume "vol1-pv" deleted
alex@ubu04:~/kuber2025/2.2$ kubectl get pv
No resources found
```
После удаления pv файл остался на своем месте, так как в конфигурации pv не указана политика persistantVolumeReclaimPolicy и для нее используется значение по умолчанию: "Retain", котрое говорит о том, что необходимо оставить содержимое pv на диске при удалении pv:
```bash
alex@ubu04:~/kuber2025/2.2$ ll  /var/data/pv1/
total 12
drwxrwxrwx 2 root root 4096 авг 16 18:23 ./
drwxr-xr-x 3 root root 4096 авг 16 18:18 ../
-rw-r--r-- 1 root root  406 авг 16 18:44 file.txt
```

------

### Задание 2

**Что нужно сделать**

Создать Deployment приложения, которое может хранить файлы на NFS с динамическим созданием PV.

1. Включить и настроить NFS-сервер на MicroK8S.
2. Создать Deployment приложения состоящего из multitool, и подключить к нему PV, созданный автоматически на сервере NFS.
3. Продемонстрировать возможность чтения и записи файла изнутри пода. 
4. Предоставить манифесты, а также скриншоты или вывод необходимых команд.


#### Решение 2.

Включение microk8s NFS-серевра:

```bash
alex@ubu04:~/kuber2025/2.2$ microk8s enable hostpath-storage
Infer repository core for addon hostpath-storage
Enabling default storage class.
WARNING: Hostpath storage is not suitable for production environments.
         A hostpath volume can grow beyond the size limit set in the volume claim manifest.

[sudo] password for alex: 
deployment.apps/hostpath-provisioner created
storageclass.storage.k8s.io/microk8s-hostpath created
serviceaccount/microk8s-hostpath created
clusterrole.rbac.authorization.k8s.io/microk8s-hostpath created
clusterrolebinding.rbac.authorization.k8s.io/microk8s-hostpath created
Storage will be available soon.
alex@ubu04:~/kuber2025/2.2$ 
```
```bash
alex@ubu04:~/kuber2025/2.2$ kubectl get storageclasses.storage.k8s.io 
NAME                          PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
microk8s-hostpath (default)   microk8s.io/hostpath   Delete          WaitForFirstConsumer   false                  112s
```

deploy:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: multi
  labels:
    app: multi
spec:
  replicas: 1
  selector:
    matchLabels:
      app: multi
  template:
    metadata:
      labels:
        app: multi
    spec:
      containers:
      - name: wbitt
        image: wbitt/network-multitool
        env:
        - name: HTTP_PORT
          value: "8080"
        - name: HTTPS_PORT 
          value: "8443"
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: vol1
          mountPath: /input
      volumes: 
      - name: vol1  
        persistentVolumeClaim:
          claimName: vol1-pvc

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: vol1-pvc
  namespace: default
spec:
  storageClassName: "microk8s-hostpath"
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

```
Развертывание deploy:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl apply -f deploy2.2.2.yaml 
deployment.apps/multi created
persistentvolumeclaim/vol1-pvc created
alex@ubu04:~/kuber2025/2.2$ kubectl get pvc
NAME       STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        VOLUMEATTRIBUTESCLASS   AGE
vol1-pvc   Bound    pvc-11ec26a8-f8e8-4fab-85c2-05ada2ed7fc5   1Gi        RWO            microk8s-hostpath   <unset>                 12s
alex@ubu04:~/kuber2025/2.2$ kubectl get pv
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM              STORAGECLASS        VOLUMEATTRIBUTESCLASS   REASON   AGE
pvc-11ec26a8-f8e8-4fab-85c2-05ada2ed7fc5   1Gi        RWO            Delete           Bound    default/vol1-pvc   microk8s-hostpath   <unset>                          13s
```
Проверка записи внутри пода:

```bash
alex@ubu04:~/kuber2025/2.2$ kubectl exec -it deployments/multi -c wbitt -it --  bash
multi-7b55f8fcff-7d9nf:/# echo "trololo" > /input/test.txt
multi-7b55f8fcff-7d9nf:/# cat /input/test.txt 
trololo
multi-7b55f8fcff-7d9nf:/# 
```


------

### Правила приёма работы

1. Домашняя работа оформляется в своём Git-репозитории в файле README.md. Выполненное задание пришлите ссылкой на .md-файл в вашем репозитории.
2. Файл README.md должен содержать скриншоты вывода необходимых команд `kubectl`, а также скриншоты результатов.
3. Репозиторий должен содержать тексты манифестов или ссылки на них в файле README.md.
